// Code generated by protoc-gen-go.
// source: graw.proto
// DO NOT EDIT!

/*
Package data is a generated protocol buffer package.

It is generated from these files:
	graw.proto

It has these top-level messages:
	UserAgent
	Redditor
	SubredditKarma
	KarmaList
*/
package data

import proto "github.com/golang/protobuf/proto"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

// UserAgent describes a non-user entity controlling a reddit account. This
// information is REQUIRED according the reddit api rules.
type UserAgent struct {
	UserAgent        *string `protobuf:"bytes,1,req,name=user_agent" json:"user_agent,omitempty"`
	ClientId         *string `protobuf:"bytes,2,req,name=client_id" json:"client_id,omitempty"`
	ClientSecret     *string `protobuf:"bytes,3,req,name=client_secret" json:"client_secret,omitempty"`
	Username         *string `protobuf:"bytes,4,req,name=username" json:"username,omitempty"`
	Password         *string `protobuf:"bytes,5,req,name=password" json:"password,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *UserAgent) Reset()         { *m = UserAgent{} }
func (m *UserAgent) String() string { return proto.CompactTextString(m) }
func (*UserAgent) ProtoMessage()    {}

func (m *UserAgent) GetUserAgent() string {
	if m != nil && m.UserAgent != nil {
		return *m.UserAgent
	}
	return ""
}

func (m *UserAgent) GetClientId() string {
	if m != nil && m.ClientId != nil {
		return *m.ClientId
	}
	return ""
}

func (m *UserAgent) GetClientSecret() string {
	if m != nil && m.ClientSecret != nil {
		return *m.ClientSecret
	}
	return ""
}

func (m *UserAgent) GetUsername() string {
	if m != nil && m.Username != nil {
		return *m.Username
	}
	return ""
}

func (m *UserAgent) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

// Redditor describes a reddit account. Some of these fields are never filled
// for accounts other than the authenticated one. (You can't count someone
// else's messages.)
type Redditor struct {
	Name             *string  `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Id               *string  `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	LinkKarma        *int32   `protobuf:"varint,3,opt,name=link_karma" json:"link_karma,omitempty"`
	CommentKarma     *int32   `protobuf:"varint,4,opt,name=comment_karma" json:"comment_karma,omitempty"`
	IsMod            *bool    `protobuf:"varint,5,opt,name=is_mod" json:"is_mod,omitempty"`
	HasModMail       *bool    `protobuf:"varint,6,opt,name=has_mod_mail" json:"has_mod_mail,omitempty"`
	HasMail          *bool    `protobuf:"varint,7,opt,name=has_mail" json:"has_mail,omitempty"`
	InboxCount       *int32   `protobuf:"varint,8,opt,name=inbox_count" json:"inbox_count,omitempty"`
	Created          *float64 `protobuf:"fixed64,9,opt,name=created" json:"created,omitempty"`
	CreatedUtc       *float64 `protobuf:"fixed64,10,opt,name=created_utc" json:"created_utc,omitempty"`
	IsGold           *bool    `protobuf:"varint,11,opt,name=is_gold" json:"is_gold,omitempty"`
	GoldCredits      *int32   `protobuf:"varint,12,opt,name=gold_credits" json:"gold_credits,omitempty"`
	GoldExpiration   *float64 `protobuf:"fixed64,13,opt,name=gold_expiration" json:"gold_expiration,omitempty"`
	Over_18          *bool    `protobuf:"varint,14,opt,name=over_18" json:"over_18,omitempty"`
	HasVerifiedEmail *bool    `protobuf:"varint,15,opt,name=has_verified_email" json:"has_verified_email,omitempty"`
	HideFromRobots   *bool    `protobuf:"varint,16,opt,name=hide_from_robots" json:"hide_from_robots,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Redditor) Reset()         { *m = Redditor{} }
func (m *Redditor) String() string { return proto.CompactTextString(m) }
func (*Redditor) ProtoMessage()    {}

func (m *Redditor) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Redditor) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *Redditor) GetLinkKarma() int32 {
	if m != nil && m.LinkKarma != nil {
		return *m.LinkKarma
	}
	return 0
}

func (m *Redditor) GetCommentKarma() int32 {
	if m != nil && m.CommentKarma != nil {
		return *m.CommentKarma
	}
	return 0
}

func (m *Redditor) GetIsMod() bool {
	if m != nil && m.IsMod != nil {
		return *m.IsMod
	}
	return false
}

func (m *Redditor) GetHasModMail() bool {
	if m != nil && m.HasModMail != nil {
		return *m.HasModMail
	}
	return false
}

func (m *Redditor) GetHasMail() bool {
	if m != nil && m.HasMail != nil {
		return *m.HasMail
	}
	return false
}

func (m *Redditor) GetInboxCount() int32 {
	if m != nil && m.InboxCount != nil {
		return *m.InboxCount
	}
	return 0
}

func (m *Redditor) GetCreated() float64 {
	if m != nil && m.Created != nil {
		return *m.Created
	}
	return 0
}

func (m *Redditor) GetCreatedUtc() float64 {
	if m != nil && m.CreatedUtc != nil {
		return *m.CreatedUtc
	}
	return 0
}

func (m *Redditor) GetIsGold() bool {
	if m != nil && m.IsGold != nil {
		return *m.IsGold
	}
	return false
}

func (m *Redditor) GetGoldCredits() int32 {
	if m != nil && m.GoldCredits != nil {
		return *m.GoldCredits
	}
	return 0
}

func (m *Redditor) GetGoldExpiration() float64 {
	if m != nil && m.GoldExpiration != nil {
		return *m.GoldExpiration
	}
	return 0
}

func (m *Redditor) GetOver_18() bool {
	if m != nil && m.Over_18 != nil {
		return *m.Over_18
	}
	return false
}

func (m *Redditor) GetHasVerifiedEmail() bool {
	if m != nil && m.HasVerifiedEmail != nil {
		return *m.HasVerifiedEmail
	}
	return false
}

func (m *Redditor) GetHideFromRobots() bool {
	if m != nil && m.HideFromRobots != nil {
		return *m.HideFromRobots
	}
	return false
}

// SubredditKarma describes karma for a given subreddit
type SubredditKarma struct {
	Sr               *string `protobuf:"bytes,1,opt,name=sr" json:"sr,omitempty"`
	LinkKarma        *int32  `protobuf:"varint,2,opt,name=link_karma" json:"link_karma,omitempty"`
	CommentKarma     *int32  `protobuf:"varint,3,opt,name=comment_karma" json:"comment_karma,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SubredditKarma) Reset()         { *m = SubredditKarma{} }
func (m *SubredditKarma) String() string { return proto.CompactTextString(m) }
func (*SubredditKarma) ProtoMessage()    {}

func (m *SubredditKarma) GetSr() string {
	if m != nil && m.Sr != nil {
		return *m.Sr
	}
	return ""
}

func (m *SubredditKarma) GetLinkKarma() int32 {
	if m != nil && m.LinkKarma != nil {
		return *m.LinkKarma
	}
	return 0
}

func (m *SubredditKarma) GetCommentKarma() int32 {
	if m != nil && m.CommentKarma != nil {
		return *m.CommentKarma
	}
	return 0
}

// KarmaList describes a karma breakdown by subreddit.
type KarmaList struct {
	// data contains the list of subreddits with their karma breakdown.
	Data             []*SubredditKarma `protobuf:"bytes,2,rep,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *KarmaList) Reset()         { *m = KarmaList{} }
func (m *KarmaList) String() string { return proto.CompactTextString(m) }
func (*KarmaList) ProtoMessage()    {}

func (m *KarmaList) GetData() []*SubredditKarma {
	if m != nil {
		return m.Data
	}
	return nil
}
